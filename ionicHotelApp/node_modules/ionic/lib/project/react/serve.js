"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const format_1 = require("@ionic/cli-framework/utils/format");
const utils_network_1 = require("@ionic/utils-network");
const color_1 = require("../../color");
const serve_1 = require("../../serve");
class ReactServeRunner extends serve_1.ServeRunner {
    constructor(e) {
        super();
        this.e = e;
    }
    async getCommandMetadata() {
        return {
            description: `
    ${color_1.input('ionic serve')} uses React Scripts. See the ${color_1.input('create-react-app')} docs[^cra-build-docs] for explanations. This command interprets the arguments to environment variables supported by React Scripts.
      `,
            footnotes: [
                {
                    id: 'cra-build-docs',
                    url: 'https://facebook.github.io/create-react-app/docs/advanced-configuration',
                },
            ],
            options: [
                {
                    name: 'https',
                    summary: 'Use HTTPS for the dev server',
                    type: Boolean,
                },
                {
                    name: 'react-editor',
                    summary: `Specify the editor for app crash links.`,
                    type: String,
                },
                {
                    name: 'ci',
                    summary: `Treat all warnings as build failures. Also makes the test runner non-watching.`,
                    type: Boolean,
                },
                {
                    name: 'livereload',
                    summary: 'Do not spin up dev server--just serve files',
                    type: Boolean,
                    default: true,
                    groups: ["hidden" /* HIDDEN */],
                },
            ],
            groups: ["beta" /* BETA */],
        };
    }
    createOptionsFromCommandLine(inputs, options) {
        const baseOptions = super.createOptionsFromCommandLine(inputs, options);
        const ci = options['ci'] ? Boolean(options['ci']) : undefined;
        const https = options['https'] ? Boolean(options['https']) : undefined;
        const reactEditor = options['reactEditor'] ? String(options['reactEditor']) : undefined;
        return {
            ...baseOptions,
            ci,
            https,
            reactEditor,
        };
    }
    modifyOpenURL(url, options) {
        return url;
    }
    async serveProject(options) {
        const [externalIP, availableInterfaces] = await this.selectExternalIP(options);
        const port = options.port = await utils_network_1.findClosestOpenPort(options.port);
        const reactScripts = new ReactServeCLI(this.e);
        await reactScripts.serve(options);
        return {
            custom: reactScripts.resolvedProgram !== reactScripts.program,
            protocol: options.https ? 'https' : 'http',
            localAddress: 'localhost',
            externalAddress: externalIP,
            externalNetworkInterfaces: availableInterfaces,
            port,
            externallyAccessible: ![serve_1.BIND_ALL_ADDRESS, ...serve_1.LOCAL_ADDRESSES].includes(externalIP),
        };
    }
}
exports.ReactServeRunner = ReactServeRunner;
class ReactServeCLI extends serve_1.ServeCLI {
    constructor() {
        super(...arguments);
        this.name = 'React Scripts';
        this.pkg = 'react-scripts';
        this.program = 'react-scripts';
        this.prefix = 'react-scripts';
        this.script = serve_1.SERVE_SCRIPT;
        this.chunks = 0;
    }
    async serve(options) {
        this.on('compile', chunks => {
            if (chunks > 0) {
                this.e.log.info(`... and ${color_1.strong(chunks.toString())} additional chunks`);
            }
        });
        return super.serve(options);
    }
    stdoutFilter(line) {
        if (this.resolvedProgram !== this.program) {
            return super.stdoutFilter(line);
        }
        const strippedLine = format_1.stripAnsi(line);
        if (strippedLine.includes('Compiled successfully')) {
            this.emit('ready');
            return false;
        }
        if (strippedLine.match(/.*chunk\s{\d+}.+/)) {
            this.chunks++;
            return false;
        }
        if (strippedLine.includes('Compiled successfully')) {
            this.emit('compile', this.chunks);
            this.chunks = 0;
        }
        return true;
    }
    async buildArgs(options) {
        const { pkgManagerArgs } = await Promise.resolve().then(() => require('../../utils/npm'));
        if (this.resolvedProgram === this.program) {
            return ['start'];
        }
        else {
            const [, ...pkgArgs] = await pkgManagerArgs(this.e.config.get('npmClient'), { command: 'run', script: this.script });
            return pkgArgs;
        }
    }
    async buildEnvVars(options) {
        const envVars = {};
        envVars.BROWSER = 'none';
        /*
          By default, CRA binds to localhost,
          but if you specify it, it puts a warning in the console,
          so don't set the HOST if the address is set to 'localhost'
        */
        if (options.address !== serve_1.DEFAULT_ADDRESS) {
            envVars.HOST = options.address;
        }
        envVars.PORT = String(options.port);
        envVars.HTTPS = (options.https === true) ? 'true' : 'false';
        envVars.CI = (options.ci === true) ? 'true' : 'false';
        if (options.reactEditor) {
            envVars.REACT = options.reactEditor;
        }
        return envVars;
    }
}
exports.ReactServeCLI = ReactServeCLI;
