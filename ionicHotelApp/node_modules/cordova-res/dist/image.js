"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const utils_fs_1 = require("@ionic/utils-fs");
const debug_1 = tslib_1.__importDefault(require("debug"));
const sharp_1 = tslib_1.__importDefault(require("sharp"));
const util_1 = tslib_1.__importDefault(require("util"));
const error_1 = require("./error");
const resources_1 = require("./resources");
const debug = debug_1.default('cordova-res:image');
/**
 * Check an array of source files, returning the first viable image.
 */
async function resolveSourceImage(platform, type, sources, errstream) {
    const errors = [];
    for (const source of sources) {
        try {
            return await readSourceImage(platform, type, source, errstream);
        }
        catch (e) {
            errors.push([source, e]);
        }
    }
    for (const [source, error] of errors) {
        debugSourceImage(source, error, errstream);
    }
    throw new error_1.ResolveSourceImageError(`Missing source image for "${type}" (sources: ${sources.join(', ')})`, errors.map(([, error]) => error).filter((e) => e instanceof error_1.ValidationError));
}
exports.resolveSourceImage = resolveSourceImage;
async function readSourceImage(platform, type, src, errstream) {
    const image = sharp_1.default(await utils_fs_1.readFile(src));
    const metadata = await resources_1.RASTER_RESOURCE_VALIDATORS[type](src, image);
    debug('Source image for %s: %O', type, metadata);
    return {
        platform,
        resource: type,
        type: "raster" /* RASTER */,
        src,
        image: { src, pipeline: image, metadata },
    };
}
exports.readSourceImage = readSourceImage;
function debugSourceImage(src, error, errstream) {
    if (error.code === 'ENOENT') {
        debug('Source file missing: %s', src);
    }
    else {
        if (errstream) {
            const message = util_1.default.format('WARN: Error with source file %s: %s', src, error);
            errstream.write(`${message}\n`);
        }
        else {
            debug('Error with source file %s: %O', src, error);
        }
    }
}
exports.debugSourceImage = debugSourceImage;
async function generateImage(image, src, metadata, errstream) {
    debug('Generating %o (%ox%o)', image.src, image.width, image.height);
    if (image.format === "none" /* NONE */) {
        return;
    }
    if (errstream) {
        if (metadata.format !== image.format) {
            errstream.write(`WARN: Must perform conversion from ${metadata.format} to png.\n`);
        }
    }
    const pipeline = applyFormatConversion(image.format, transformImage(image, src));
    await utils_fs_1.writeFile(image.src, await pipeline.toBuffer());
}
exports.generateImage = generateImage;
function transformImage(image, src) {
    return src.resize(image.width, image.height);
}
exports.transformImage = transformImage;
function applyFormatConversion(format, src) {
    switch (format) {
        case "png" /* PNG */:
            return src.png();
        case "jpeg" /* JPEG */:
            return src.jpeg();
    }
    return src;
}
exports.applyFormatConversion = applyFormatConversion;
