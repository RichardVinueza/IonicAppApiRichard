"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const utils_fs_1 = require("@ionic/utils-fs");
const debug_1 = tslib_1.__importDefault(require("debug"));
const path_1 = tslib_1.__importDefault(require("path"));
const error_1 = require("./error");
const image_1 = require("./image");
const resources_1 = require("./resources");
const debug = debug_1.default('cordova-res:platform');
exports.PLATFORMS = ["android" /* ANDROID */, "ios" /* IOS */, "windows" /* WINDOWS */];
/**
 * Run resource generation for the given platform.
 */
async function run(platform, resourcesDirectory, options, errstream) {
    debug('Running %s platform with options: %O', platform, options);
    const resources = [];
    const sources = [];
    const adaptiveResult = await safelyGenerateAdaptiveIconResources(platform, resourcesDirectory, options["adaptive-icon" /* ADAPTIVE_ICON */], errstream);
    if (adaptiveResult && adaptiveResult.resources.length > 0) {
        resources.push(...adaptiveResult.resources);
        sources.push(...adaptiveResult.sources);
    }
    else {
        const iconResult = await generateSimpleResources("icon" /* ICON */, platform, resourcesDirectory, options["icon" /* ICON */], errstream);
        if (iconResult) {
            resources.push(...iconResult.resources);
            sources.push(iconResult.source);
        }
    }
    const splashResult = await generateSimpleResources("splash" /* SPLASH */, platform, resourcesDirectory, options["splash" /* SPLASH */], errstream);
    if (splashResult) {
        resources.push(...splashResult.resources);
        sources.push(splashResult.source);
    }
    return {
        resources,
        sources,
    };
}
exports.run = run;
/**
 * Attempt to generate icons or splash screens for any platform.
 *
 * If there are no options given for this resource or if the source images are
 * not suitable, this function resolves with `undefined`.
 */
async function safelyGenerateSimpleResources(type, platform, resourcesDirectory, options, errstream) {
    if (!options) {
        return;
    }
    try {
        return await generateSimpleResources(type, platform, resourcesDirectory, options, errstream);
    }
    catch (e) {
        debug('Error with %O resources for %O: %O', type, platform, e);
        if (!(e instanceof error_1.ResolveSourceImageError)) {
            throw e;
        }
    }
}
exports.safelyGenerateSimpleResources = safelyGenerateSimpleResources;
/**
 * Generate simple icons or splash screens.
 *
 * Icon and Splash Screen generation is "simple" because there's one source
 * image type and one set of resources to generate.
 *
 * If there are no options given for this resource, this function resolves
 * with `undefined`.
 */
async function generateSimpleResources(type, platform, resourcesDirectory, options, errstream) {
    if (!options) {
        return;
    }
    debug('Building %s resources for %s platform', type, platform);
    const source = await image_1.resolveSourceImage(platform, type, options.sources.map(s => imageSourceToPath(s)), errstream);
    debug('Using %O for %s source image for %s', source.image.src, type, platform);
    const config = resources_1.getResourcesConfig(platform, type);
    const resources = await Promise.all(config.resources.map(async (resource) => (Object.assign({}, resource, await generateImageResource(type, platform, resourcesDirectory, config, source.image, resource, errstream)))));
    return {
        resources,
        source,
    };
}
exports.generateSimpleResources = generateSimpleResources;
/**
 * Attempt to generate Adaptive Icons for any platform.
 *
 * If there are no options given for this resource or if the platform or
 * source images are not suitable, this function resolves with `undefined`.
 */
async function safelyGenerateAdaptiveIconResources(platform, resourcesDirectory, options, errstream) {
    if (!options || platform !== "android" /* ANDROID */) {
        return;
    }
    try {
        return await generateAdaptiveIconResources(resourcesDirectory, options, errstream);
    }
    catch (e) {
        debug('Error with adaptive icons: %O', e);
        if (!(e instanceof error_1.ResolveSourceImageError)) {
            throw e;
        }
    }
}
exports.safelyGenerateAdaptiveIconResources = safelyGenerateAdaptiveIconResources;
/**
 * Generate Android Adaptive Icons.
 */
async function generateAdaptiveIconResources(resourcesDirectory, options, errstream) {
    if (options.foreground.sources.length === 0 || options.background.sources.length === 0) {
        throw new error_1.BadInputError('Adaptive icons require sources for both foreground and background.');
    }
    debug('Building %s resources', "adaptive-icon" /* ADAPTIVE_ICON */);
    const { resources: iconResources = [], source: iconSource } = (await safelyGenerateSimpleResources("icon" /* ICON */, "android" /* ANDROID */, resourcesDirectory, options.icon, errstream)) || { source: undefined };
    const { resources: foregroundResources, source: foregroundSource } = await generateAdaptiveIconResourcesPortion(resourcesDirectory, "foreground" /* FOREGROUND */, options.foreground.sources, errstream);
    const resolvedBackgroundSource = await resolveSource("android" /* ANDROID */, "adaptive-icon" /* ADAPTIVE_ICON */, "background" /* BACKGROUND */, options.background.sources, errstream);
    const backgroundResources = resolvedBackgroundSource.type === "raster" /* RASTER */
        ? await generateAdaptiveIconResourcesPortionFromImageSource(resourcesDirectory, "background" /* BACKGROUND */, resolvedBackgroundSource, errstream)
        : foregroundResources.map(resource => (Object.assign({}, resource, { src: '@color/background' })));
    const resources = await consolidateAdaptiveIconResources(foregroundResources, backgroundResources);
    return {
        resources: [...iconResources, ...resources],
        sources: [...iconSource ? [iconSource] : [], foregroundSource, resolvedBackgroundSource],
    };
}
exports.generateAdaptiveIconResources = generateAdaptiveIconResources;
async function consolidateAdaptiveIconResources(foregrounds, backgrounds) {
    return foregrounds.map(foreground => {
        const background = backgrounds.find(r => r[r.indexAttribute.key] === foreground[foreground.indexAttribute.key]);
        if (!background) {
            throw new error_1.BadInputError(`Cannot consolidate adaptive icon resources: No background for foreground: ${foreground.src}`);
        }
        return {
            platform: foreground.platform,
            type: foreground.type,
            foreground: foreground.src,
            background: background.src,
            density: foreground.density,
            width: foreground.width,
            height: foreground.height,
            nodeName: foreground.nodeName,
            nodeAttributes: foreground.nodeAttributes,
            indexAttribute: foreground.indexAttribute,
        };
    });
}
exports.consolidateAdaptiveIconResources = consolidateAdaptiveIconResources;
/**
 * Generate the foreground of Adaptive Icons.
 */
async function generateAdaptiveIconResourcesPortion(resourcesDirectory, type, sources, errstream) {
    const source = await image_1.resolveSourceImage("android" /* ANDROID */, "adaptive-icon" /* ADAPTIVE_ICON */, sources.map(s => imageSourceToPath(s)), errstream);
    return {
        resources: await generateAdaptiveIconResourcesPortionFromImageSource(resourcesDirectory, type, source, errstream),
        source,
    };
}
exports.generateAdaptiveIconResourcesPortion = generateAdaptiveIconResourcesPortion;
async function generateAdaptiveIconResourcesPortionFromImageSource(resourcesDirectory, type, source, errstream) {
    debug('Using %O for %s source image for %s', source.image.src, "adaptive-icon" /* ADAPTIVE_ICON */, "android" /* ANDROID */);
    const config = resources_1.getResourcesConfig("android" /* ANDROID */, "adaptive-icon" /* ADAPTIVE_ICON */);
    const resources = await Promise.all(config.resources.map(async (resource) => (Object.assign({}, resource, await generateImageResource("adaptive-icon" /* ADAPTIVE_ICON */, "android" /* ANDROID */, resourcesDirectory, config, source.image, Object.assign({}, resource, { src: resource[type] }), errstream)))));
    return resources;
}
exports.generateAdaptiveIconResourcesPortionFromImageSource = generateAdaptiveIconResourcesPortionFromImageSource;
async function generateImageResource(type, platform, resourcesDirectory, config, image, schema, errstream) {
    const { pipeline, metadata } = image;
    const { src, format, width, height } = schema;
    const dest = path_1.default.join(resourcesDirectory, src);
    await utils_fs_1.ensureDir(path_1.default.dirname(dest));
    await image_1.generateImage({ src: dest, format, width, height }, pipeline.clone(), metadata, errstream);
    return {
        type,
        format,
        width,
        height,
        src: dest,
        platform,
        nodeName: config.nodeName,
        nodeAttributes: config.nodeAttributes,
        indexAttribute: config.indexAttribute,
    };
}
exports.generateImageResource = generateImageResource;
function imageSourceToPath(source) {
    return typeof source === 'string' ? source : source.src;
}
exports.imageSourceToPath = imageSourceToPath;
async function resolveSource(platform, type, name, sources, errstream) {
    for (const source of sources) {
        if (typeof source === 'string' || source.type === "raster" /* RASTER */) {
            const src = imageSourceToPath(source);
            try {
                return await image_1.readSourceImage(platform, type, src);
            }
            catch (e) {
                image_1.debugSourceImage(src, e, errstream);
            }
        }
        else if (source.type === "color" /* COLOR */) {
            const color = source.color.toUpperCase();
            if (!color.match(resources_1.COLOR_REGEX)) {
                throw new error_1.BadInputError(`Color ${color} does not match regex ${resources_1.COLOR_REGEX}.`);
            }
            return { platform, resource: type, type: "color" /* COLOR */, name, color };
        }
    }
    throw new error_1.BadInputError(`Missing source for "${type}" (sources: ${sources.join(', ')})`);
}
exports.resolveSource = resolveSource;
function validatePlatforms(platforms) {
    const result = [];
    for (const platform of platforms) {
        if (!isSupportedPlatform(platform)) {
            throw new error_1.BadInputError(`Unsupported platform: ${platform}`);
        }
        result.push(platform);
    }
    return result;
}
exports.validatePlatforms = validatePlatforms;
function filterSupportedPlatforms(platforms) {
    return platforms.filter(isSupportedPlatform);
}
exports.filterSupportedPlatforms = filterSupportedPlatforms;
function isSupportedPlatform(platform) {
    return exports.PLATFORMS.includes(platform);
}
exports.isSupportedPlatform = isSupportedPlatform;
