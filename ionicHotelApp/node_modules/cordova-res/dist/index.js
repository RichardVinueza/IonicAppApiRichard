"use strict";
const tslib_1 = require("tslib");
const utils_fs_1 = require("@ionic/utils-fs");
const debug_1 = tslib_1.__importDefault(require("debug"));
const path_1 = tslib_1.__importDefault(require("path"));
const cli_1 = require("./cli");
const config_1 = require("./config");
const error_1 = require("./error");
const platform_1 = require("./platform");
const resources_1 = require("./resources");
const fn_1 = require("./utils/fn");
const debug = debug_1.default('cordova-res');
async function CordovaRes({ directory = cli_1.getDirectory(), resourcesDirectory = resources_1.DEFAULT_RESOURCES_DIRECTORY, logstream = process.stdout, errstream = process.stderr, platforms = {
    ["android" /* ANDROID */]: cli_1.generateRunOptions("android" /* ANDROID */, resourcesDirectory, []),
    ["ios" /* IOS */]: cli_1.generateRunOptions("ios" /* IOS */, resourcesDirectory, []),
    ["windows" /* WINDOWS */]: cli_1.generateRunOptions("windows" /* WINDOWS */, resourcesDirectory, []),
}, } = {}) {
    const configPath = config_1.getConfigPath(directory);
    debug('Paths: (config: %O) (resources dir: %O)', configPath, resourcesDirectory);
    let config;
    const resources = [];
    const sources = [];
    if (await utils_fs_1.pathWritable(configPath)) {
        config = await config_1.read(configPath);
    }
    else {
        debug('File missing/not writable: %O', configPath);
        if (errstream) {
            errstream.write(`WARN: No config.xml file in directory. Skipping config.\n`);
        }
    }
    for (const platform of platform_1.PLATFORMS) {
        const platformOptions = platforms[platform];
        if (platformOptions) {
            const platformResult = await platform_1.run(platform, resourcesDirectory, platformOptions, errstream);
            logstream.write(`Generated ${platformResult.resources.length} resources for ${platform}\n`);
            resources.push(...platformResult.resources);
            sources.push(...platformResult.sources);
        }
    }
    if (config) {
        await config_1.run(configPath, resourcesDirectory, config, sources, resources, errstream);
        await config_1.write(configPath, config);
        logstream.write(`Wrote to config.xml\n`);
    }
    return {
        resources: resources.map(resource => {
            const { platform, type, src, foreground, background, width, height, density, orientation } = resource;
            return {
                platform,
                type,
                src,
                foreground,
                background,
                width,
                height,
                density,
                orientation,
            };
        }),
        sources: sources.map(source => {
            switch (source.type) {
                case "raster" /* RASTER */:
                    return { platform: source.platform, resource: source.resource, type: "raster" /* RASTER */, value: source.src };
                case "color" /* COLOR */:
                    return { platform: source.platform, resource: source.resource, type: "color" /* COLOR */, value: source.color, name: source.name };
            }
        }),
    };
}
(function (CordovaRes) {
    CordovaRes.run = CordovaRes;
    async function runCommandLine(args) {
        if (args.includes('--version')) {
            const pkg = await Promise.resolve().then(() => tslib_1.__importStar(require(path_1.default.resolve(__dirname, '../package.json'))));
            process.stdout.write(pkg.version + '\n');
            return;
        }
        if (args[0] === 'help' || args.includes('--help') || args.includes('-h')) {
            const help = await Promise.resolve().then(() => tslib_1.__importStar(require('./help')));
            return help.run();
        }
        try {
            const directory = cli_1.getDirectory();
            const configPath = config_1.getConfigPath(directory);
            const config = await fn_1.tryFn(() => config_1.read(configPath));
            const options = await cli_1.resolveOptions(args, directory, config);
            const result = await CordovaRes.run(options);
            if (args.includes('--json')) {
                process.stdout.write(JSON.stringify(result, undefined, '\t'));
            }
        }
        catch (e) {
            debug('Caught fatal error: %O', e);
            process.exitCode = 1;
            if (args.includes('--json')) {
                process.stdout.write(JSON.stringify({ error: e instanceof error_1.BaseError ? e : e.toString() }, undefined, '\t'));
            }
            else {
                process.stderr.write(`${e instanceof error_1.BaseError ? `ERROR: ${e.toString()}` : (e.stack ? e.stack : String(e))}\n`);
            }
        }
    }
    CordovaRes.runCommandLine = runCommandLine;
})(CordovaRes || (CordovaRes = {}));
module.exports = CordovaRes;
