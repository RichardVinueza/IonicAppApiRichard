"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const config_1 = require("./config");
const error_1 = require("./error");
const platform_1 = require("./platform");
const resources_1 = require("./resources");
const cli_1 = require("./utils/cli");
function getDirectory() {
    return process.cwd();
}
exports.getDirectory = getDirectory;
async function resolveOptions(args, directory, config) {
    const doc = config ? config.getroot() : undefined;
    const platformList = platform_1.filterSupportedPlatforms(doc ? config_1.getPlatforms(doc) : []);
    const parsedOptions = parseOptions(args);
    const { resourcesDirectory = resources_1.DEFAULT_RESOURCES_DIRECTORY } = parsedOptions;
    return Object.assign({}, Object.assign({ directory }, platformList.length > 0 ? { platforms: generatePlatformOptions(platformList, resourcesDirectory, args) } : {}), parsedOptions);
}
exports.resolveOptions = resolveOptions;
function parseOptions(args) {
    const json = args.includes('--json');
    const resourcesDirectory = cli_1.getOptionValue(args, '--resources', resources_1.DEFAULT_RESOURCES_DIRECTORY);
    const platformArg = args[0] ? args[0] : undefined;
    const platformList = platform_1.validatePlatforms(platformArg && !platformArg.startsWith('-') ? [platformArg] : []);
    return Object.assign({ resourcesDirectory, logstream: json ? process.stderr : process.stdout, errstream: process.stderr }, platformList.length > 0 ? { platforms: generatePlatformOptions(platformList, resourcesDirectory, args) } : {});
}
exports.parseOptions = parseOptions;
function generatePlatformOptions(platforms, resourcesDirectory, args) {
    return platforms.reduce((acc, platform) => {
        acc[platform] = generateRunOptions(platform, resourcesDirectory, args);
        return acc;
    }, {});
}
exports.generatePlatformOptions = generatePlatformOptions;
function generateRunOptions(platform, resourcesDirectory, args) {
    const typeOption = cli_1.getOptionValue(args, '--type');
    const types = resources_1.validateResourceTypes(typeOption ? [typeOption] : resources_1.RESOURCE_TYPES);
    return {
        ["adaptive-icon" /* ADAPTIVE_ICON */]: types.includes("adaptive-icon" /* ADAPTIVE_ICON */) ? parseAdaptiveIconResourceOptions(platform, resourcesDirectory, args) : undefined,
        ["icon" /* ICON */]: types.includes("icon" /* ICON */) ? parseSimpleResourceOptions(platform, "icon" /* ICON */, resourcesDirectory, args) : undefined,
        ["splash" /* SPLASH */]: types.includes("splash" /* SPLASH */) ? parseSimpleResourceOptions(platform, "splash" /* SPLASH */, resourcesDirectory, args) : undefined,
    };
}
exports.generateRunOptions = generateRunOptions;
function parseAdaptiveIconResourceOptions(platform, resourcesDirectory, args) {
    if (platform !== "android" /* ANDROID */) {
        return;
    }
    return {
        icon: parseSimpleResourceOptions(platform, "icon" /* ICON */, resourcesDirectory, args),
        foreground: parseAdaptiveIconForegroundOptions(resourcesDirectory, args),
        background: parseAdaptiveIconBackgroundOptions(resourcesDirectory, args),
    };
}
exports.parseAdaptiveIconResourceOptions = parseAdaptiveIconResourceOptions;
function parseAdaptiveIconForegroundOptions(resourcesDirectory, args) {
    const source = parseAdaptiveIconSourceFromArgs("foreground" /* FOREGROUND */, args);
    if (source && source.type !== "raster" /* RASTER */) {
        throw new error_1.BadInputError('Adaptive icon foreground must be an image.');
    }
    return {
        sources: source
            ? [source]
            : getDefaultAdaptiveIconSources("foreground" /* FOREGROUND */, resourcesDirectory),
    };
}
exports.parseAdaptiveIconForegroundOptions = parseAdaptiveIconForegroundOptions;
function parseAdaptiveIconBackgroundOptions(resourcesDirectory, args) {
    const source = parseAdaptiveIconSourceFromArgs("background" /* BACKGROUND */, args);
    return {
        sources: source
            ? [source]
            : getDefaultAdaptiveIconSources("background" /* BACKGROUND */, resourcesDirectory),
    };
}
exports.parseAdaptiveIconBackgroundOptions = parseAdaptiveIconBackgroundOptions;
function parseSimpleResourceOptions(platform, type, resourcesDirectory, args) {
    const source = parseSourceFromArgs(type, args);
    return { sources: source ? [source] : getDefaultSources(platform, type, resourcesDirectory) };
}
exports.parseSimpleResourceOptions = parseSimpleResourceOptions;
function parseAdaptiveIconSourceFromArgs(type, args) {
    const sourceOption = cli_1.getOptionValue(args, `--icon-${type}-source`);
    if (!sourceOption) {
        return;
    }
    return parseSource(sourceOption);
}
exports.parseAdaptiveIconSourceFromArgs = parseAdaptiveIconSourceFromArgs;
function parseSourceFromArgs(type, args) {
    const sourceOption = cli_1.getOptionValue(args, `--${type}-source`);
    if (sourceOption) {
        return sourceOption;
    }
}
exports.parseSourceFromArgs = parseSourceFromArgs;
function parseSource(sourceOption) {
    return sourceOption.startsWith('#')
        ? { type: "color" /* COLOR */, color: sourceOption }
        : { type: "raster" /* RASTER */, src: sourceOption };
}
exports.parseSource = parseSource;
function getDefaultSources(platform, type, resourcesDirectory) {
    return [
        `${resourcesDirectory}/${platform}/${type}.png`,
        `${resourcesDirectory}/${platform}/${type}.jpg`,
        `${resourcesDirectory}/${platform}/${type}.jpeg`,
        `${resourcesDirectory}/${type}.png`,
        `${resourcesDirectory}/${type}.jpg`,
        `${resourcesDirectory}/${type}.jpeg`,
    ];
}
exports.getDefaultSources = getDefaultSources;
function getDefaultAdaptiveIconSources(type, resourcesDirectory) {
    return [
        `${resourcesDirectory}/android/icon-${type}.png`,
        `${resourcesDirectory}/android/icon-${type}.jpg`,
        `${resourcesDirectory}/android/icon-${type}.jpeg`,
    ];
}
exports.getDefaultAdaptiveIconSources = getDefaultAdaptiveIconSources;
