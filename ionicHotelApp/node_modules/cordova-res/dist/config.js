"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const utils_fs_1 = require("@ionic/utils-fs");
const debug_1 = tslib_1.__importDefault(require("debug"));
const elementtree_1 = tslib_1.__importDefault(require("elementtree"));
const path_1 = tslib_1.__importDefault(require("path"));
const error_1 = require("./error");
const debug = debug_1.default('cordova-res:config');
function getConfigPath(directory) {
    return path_1.default.resolve(directory, 'config.xml');
}
exports.getConfigPath = getConfigPath;
async function run(configPath, resourcesDirectory, doc, sources, resources, errstream) {
    const colors = sources.filter((source) => source.type === "color" /* COLOR */);
    const androidPlatformElement = resolvePlatformElement(doc.getroot(), "android" /* ANDROID */);
    if (colors.length > 0) {
        debug('Color sources found--generating colors document.');
        const colorsPath = path_1.default.join(resourcesDirectory, 'values', 'colors.xml');
        await runColorsConfig(colorsPath, colors);
        let resourceFileElement = androidPlatformElement.find(`resource-file[@src='${colorsPath}']`);
        if (!resourceFileElement) {
            resourceFileElement = elementtree_1.default.SubElement(androidPlatformElement, 'resource-file');
        }
        resourceFileElement.set('src', colorsPath);
        resourceFileElement.set('target', '/app/src/main/res/values/colors.xml');
    }
    runConfig(configPath, doc, resources, errstream);
}
exports.run = run;
async function resolveColorsDocument(colorsPath) {
    try {
        return await read(colorsPath);
    }
    catch (e) {
        if (e.code !== 'ENOENT') {
            throw e;
        }
        const element = elementtree_1.default.Element('resources');
        return new elementtree_1.default.ElementTree(element);
    }
}
exports.resolveColorsDocument = resolveColorsDocument;
async function runColorsConfig(colorsPath, colors) {
    await utils_fs_1.ensureDir(path_1.default.dirname(colorsPath));
    const colorsDocument = await resolveColorsDocument(colorsPath);
    const root = colorsDocument.getroot();
    for (const color of colors) {
        let colorElement = root.find(`color[@name='${color.name}']`);
        if (!colorElement) {
            debug('Creating node for %o', color.name);
            colorElement = elementtree_1.default.SubElement(root, 'color');
        }
        colorElement.set('name', color.name);
        colorElement.text = color.color;
    }
    await write(colorsPath, colorsDocument);
}
exports.runColorsConfig = runColorsConfig;
function runConfig(configPath, doc, resources, errstream) {
    const root = doc.getroot();
    const orientationPreference = getPreference(root, 'Orientation');
    debug('Orientation preference: %O', orientationPreference);
    const orientation = orientationPreference || 'default';
    if (orientation !== 'default' && errstream) {
        errstream.write(`WARN: Orientation preference set to '${orientation}'. Only configuring ${orientation} resources.\n`);
    }
    const platforms = groupImages(resources);
    for (const [platform, platformResources] of platforms) {
        const platformElement = resolvePlatformElement(root, platform);
        let filteredResources = platformResources.filter(img => orientation === 'default' || typeof img.orientation === 'undefined' || img.orientation === orientation);
        if (platform === "windows" /* WINDOWS */) {
            filteredResources = filteredResources.filter(img => typeof img.target === 'string');
        }
        for (const resource of filteredResources) {
            runResource(configPath, platformElement, resource);
        }
    }
}
exports.runConfig = runConfig;
function conformPath(configPath, value) {
    return path_1.default.relative(path_1.default.dirname(configPath), value.toString()).replace(/\\/g, '/');
}
exports.conformPath = conformPath;
function runResource(configPath, container, resource) {
    const src = resource[resource.indexAttribute.key];
    if (typeof src !== 'string') {
        throw new error_1.BadInputError(`Bad value for index "${resource.indexAttribute.key}": ${src}`);
    }
    // We force the use of forward slashes here to provide cross-platform
    // compatibility for paths.
    const imgElement = resolveResourceElement(container, resource.nodeName, resource.indexAttribute, conformPath(configPath, src));
    for (const attr of resource.nodeAttributes) {
        const v = resource[attr.key];
        if (v) {
            imgElement.set(attr.key, attr.type === "path" /* PATH */ ? conformPath(configPath, v) : v.toString());
        }
    }
}
exports.runResource = runResource;
function resolvePlatformElement(container, platform) {
    const platformElement = container.find(`platform[@name='${platform}']`);
    if (platformElement) {
        return platformElement;
    }
    debug('Creating node for %o', platform);
    return elementtree_1.default.SubElement(container, 'platform', { name: platform });
}
exports.resolvePlatformElement = resolvePlatformElement;
function resolveResourceElement(container, nodeName, indexAttr, index) {
    const imgElement = container.find(`${nodeName}[@${indexAttr.key}='${index}']`);
    if (imgElement) {
        return imgElement;
    }
    if (indexAttr.type === "path" /* PATH */) {
        // We didn't find the element using forward slashes, so let's try to
        // find it with backslashes if the index is a path.
        const imgElementByBackslashes = container.find(`${nodeName}[@${indexAttr.key}='${index.replace(/\//g, '\\')}']`);
        if (imgElementByBackslashes) {
            return imgElementByBackslashes;
        }
    }
    debug('Creating %O node for %o', nodeName, index);
    return elementtree_1.default.SubElement(container, nodeName);
}
exports.resolveResourceElement = resolveResourceElement;
function groupImages(images) {
    const platforms = new Map();
    for (const image of images) {
        let platformImages = platforms.get(image.platform);
        if (!platformImages) {
            platformImages = [];
        }
        platformImages.push(image);
        platforms.set(image.platform, platformImages);
    }
    return platforms;
}
exports.groupImages = groupImages;
async function read(path) {
    const contents = await utils_fs_1.readFile(path, 'utf8');
    const doc = elementtree_1.default.parse(contents);
    return doc;
}
exports.read = read;
async function write(path, doc) {
    // Cordova hard codes an indentation of 4 spaces, so we'll follow.
    const contents = doc.write({ indent: 4 });
    await utils_fs_1.writeFile(path, contents, 'utf8');
}
exports.write = write;
function getPlatforms(container) {
    const platformElements = container.findall('platform');
    const platforms = platformElements.map(el => el.get('name'));
    return platforms.filter((p) => typeof p === 'string');
}
exports.getPlatforms = getPlatforms;
function getPreference(container, name) {
    const preferenceElement = container.find(`preference[@name='${name}']`);
    if (!preferenceElement) {
        return undefined;
    }
    const value = preferenceElement.get('value');
    if (!value) {
        return undefined;
    }
    return value;
}
exports.getPreference = getPreference;
